#ifndef BEDROCK_CONSTANTS_H
#define BEDROCK_CONSTANTS_H

#include <array>
#include <cstdint>

namespace bedrock {
	constexpr auto word_size = sizeof(std::uint16_t);
	constexpr auto sector_size = 512;
	constexpr auto disk_size = sector_size * (1 << 16);
	constexpr auto words_per_sector = sector_size / word_size;

	constexpr std::array<std::uint16_t, words_per_sector> boot_sector {
		// Jump to code after assembler loop
		0x2029, // set	r0, 0x29
		0x0000, // jmp	r0, r0, r0

		// Stash the value of a newline character
		0x2F0A, // set	rf, 0xa 	; rf = '\n'

		// Wait for input, stash it
		0xE000, // srl 	r0, 0x0, r0
		0x1200, // mov	r2, r0

		// Compare to '\n'
		0xD10F, // not	r1, rf
		0xB101, // and	r1, r0, r1
		0xD000, // not	r0, r0
		0xB00F, // and	r0, r0, rf
		0xC001, // lor	r0, r0, r1	; r0 is zero if char == '\n'

		// If char did not equal '\n', skip execute jump
		0x210F, // set	r1, 0xf
		0x0001, // jmp	r0, r0, r1

		// Jump to code buffer
		0x2101, // set	r1, 0x1
		0x9181, // shl	r1, 0x8, r1
		0x0011, // jmp	r0, r1, r1	; if r1 jump to r1

		// Decide range of character
		0x203A, // set	r0, 0x3a	; r0 = ':'
		0x8002, // div	r0, r0, r2	; r0 = r2 / r0 (zero iff. r2 < ':')

		// Jump if not decimal to letter computation
		0x2117, // set	r1, 0x17
		0x0101, // jmp	r1, r0, r1	; if r0 goto r1

		// Compute decimal and skip letter computation
		0x2030, // set	r0, 0x30	; r0 = '0'
		0x6002, // sub	r0, r0, r2	; r0 = r2 - r0
		0x2119, // set	r1, 0x19
		0x0111, // jmp	r1, r1, r1

		// Compute letter
		0x2037, // set	r0, 0x37	; r0 = 'A' - 10
		0x6002, // sub	r0, r0, r2	; r0 = r2 - r0

		// Shift letter in
		0x9E4E, // shl	re, 0x4, re
		0xCE0E, // lor	re,	r0, re

		// Change state
		0x2001, // set	r0, 0x1
		0x5DD0, // add	rd, rd, r0
		0x2003, // set	r0, 0x3
		0xB00D, // and	r0, r0, rd

		// Skip write while not needed
		0x2127, // set	r1, 0x27
		0x0101, // jmp	r1, r0, r1	; if r0 goto r1

		// Write!
		0x2101, // set	r1, 0x1
		0x9081, // shl	r0, 0x8, r1
		0x500C, // add	r0, r0, rc
		0x40E0, // sto	re, r0
		0x5C1C, // add	rc, r1, rc

		// Skip newline
		0xE000, // srl	r0, 0x0, r0

		// Loop!
		0x2003, // set	r0, 0x3
		0x0000, // jmp	r0, r0, r0

		// Set pointer to string
		0x203D, // set	r0, 0x3d

		// Skip character read if register still has chars
		0x2401, // set	r4, 0x1
		0xB445, // and	r4,	r4,	r5
		0x2131, // set	r1, 0x31
		0x0141, // jmp	r1, r4, r1

		// Read character pair and advance
		0x3300, // lod	r3, r0
		0x2201, // set	r2, 0x1
		0x5002, // add	r0, r0, r2

		// Extract top character and shift
		0x24FF, // set	r4, 0xff
		0x9484, // shl	r4, 0x8, r4
		0xB143, // and	r1, r4, r3
		0xA181, // shr	r1,	0x8, r1
		0x9383, // shl	r3, 0x8, r3
		0x2401, // set	r4, 0x1
		0x5545, // add	r5, r4, r5

		// Write unpacked char
		0xE011, // srl	r0, 0x1, r1

		// Loop back if character is not null
		0x222A, // set	r2, 0x2a
		0x0212, // jmp	r2, r1, r2

		// Jump back to assembler loop
		0x2002, // set	r0, 0x2
		0x0000, // jmp	r0, r0, r0

		// Character data!
		0x496E,
		0x7465,
		0x7261,
		0x6374,
		0x6976,
		0x6520,
		0x4173,
		0x7365,
		0x6D62,
		0x6C65,
		0x720A,
		0x436F,
		0x7079,
		0x7269,
		0x6768,
		0x7420,
		0x3230,
		0x3232,
		0x2044,
		0x6176,
		0x6964,
		0x2044,
		0x6574,
		0x7765,
		0x696C,
		0x6572,
		0x0A0A,
		0x456E,
		0x7465,
		0x7220,
		0x6F6E,
		0x6520,
		0x3136,
		0x2D62,
		0x6974,
		0x2069,
		0x6E73,
		0x7472,
		0x7563,
		0x7469,
		0x6F6E,
		0x2070,
		0x6572,
		0x206C,
		0x696E,
		0x6520,
		0x696E,
		0x2061,
		0x6C6C,
		0x2D63,
		0x6170,
		0x7320,
		0x6865,
		0x7861,
		0x6465,
		0x6369,
		0x6D61,
		0x6C2E,
		0x0A46,
		0x6F72,
		0x2065,
		0x7861,
		0x6D70,
		0x6C65,
		0x2C20,
		0x7468,
		0x6520,
		0x6861,
		0x6C74,
		0x2073,
		0x6571,
		0x7565,
		0x6E63,
		0x653A,
		0x0A0A,
		0x0932,
		0x3030,
		0x310A,
		0x0946,
		0x3030,
		0x300A,
		0x0A50,
		0x7265,
		0x7373,
		0x2065,
		0x6E74,
		0x6572,
		0x2061,
		0x6761,
		0x696E,
		0x2061,
		0x6674,
		0x6572,
		0x2074,
		0x6865,
		0x206C,
		0x6173,
		0x7420,
		0x696E,
		0x7374,
		0x7275,
		0x6374,
		0x696F,
		0x6E20,
		0x746F,
		0x2065,
		0x7865,
		0x6375,
		0x7465,
		0x2061,
		0x7373,
		0x656D,
		0x626C,
		0x6564,
		0x2063,
		0x6F64,
		0x652E,
		0x0A43,
		0x6F64,
		0x6520,
		0x6973,
		0x2061,
		0x7373,
		0x656D,
		0x626C,
		0x6564,
		0x2073,
		0x6571,
		0x7565,
		0x6E74,
		0x6961,
		0x6C6C,
		0x7920,
		0x7769,
		0x7468,
		0x2062,
		0x6173,
		0x6520,
		0x6164,
		0x7265,
		0x7373,
		0x2030,
		0x7831,
		0x3030,
		0x2E0A,
		0x0A00,
	};
}

#endif
